---
typora-root-url: ./img
---

要有正规的，大气的编程习惯

# C++ 面向对象高级编程

## 简介

c++基本单元是类，即class。

基于对象（Object）：面对的是单一class的设计

- 不带有指针成员的类 complex 复数类
- 带有指针成员的类 string 字符串类

面向对象（Object Oriented）：面对的是多重class的设计，class之间的关系。

- 继承
- 复合
- 委托

演化

1. C++98 1.0
2. C++03
3. C++11 2.0
4. C++14

C++包含语言部分与标准库部分。

将数据与处理这些对象的函数包在一起，这就是类。

## C++代码组织形式

![format of cpp code](.\C++代码组成形式.PNG)

C++代码的扩展名不一定是cpp或者h，还可能是hpp甚至没有扩展名

头文件中的防卫式声明：

```c++
#ifndef __CLASSNAME__
#define __CLASSNAME__

do something

#endif

```

头文件的布局

![头文件组织形式](./头文件组织形式.PNG)

在函数体内部实现的函数是内联（inline）的，在函数体外部实现的函数需要在函数定义前面加上inline关键字才会内联，当然，这里所谓的inline只是程序员对编译器的一个建议，编译器会根据函数的复杂程度自己决定是否接受这个建议。

## 构造函数

构造函数（constructor）会在对象创建时自动调用。

构造函数没有返回值，

构造函数有一个初始化列表，这是构造函数特有的。

```c++
ClassA(int par1, double par2)
	: m_par(par1), m_par2(par2)
{
    //do something
}
```

建议在初始化列表中初始化类中的成员变量。变量有初始化与赋值两个过程，当初始化一个类，成员变量也会被初始化，初始化列表就是在做初始化成员变量这个事，如果初始化列表中什么也不做，在函数体中给成员变量赋初值，这时成员变量就会先默认初始化，然后被赋值，多一个过程，降低了效率。

构造函数可能有很多个重载（overload）。

把构造函数放到private区域：

private函数无法被外部调用，所以这样的类无法在外部实例化。 这种手段可以用来控制对象的实例化。比如实现单例模式。

函数命名：

`__doapl()` do assignment plus :做赋值加法，即+=操作。

## 常量成员函数：

在函数后面加上const，代表这个函数不会修改类的状态，即不会修改类的成员变量。成员函数分为两种，会改变成员变量的和不改变成员变量的，不改变成员变量的函数可以将其定义为常量成员函数。

```c++
double getDate() const {return m_data;}

or
//声明
int StaticFuncTestClass::getData() const;
//定义
int StaticFuncTestClass::getData() const
{
    return 0;
}
```

不加const会产生什么后果：

```c++
const ClassA a;
a.func()
```

当定义一个常量类，那么就只能调用它的常量成员函数了，不加const，编译器会怀疑这个类会改变类的成员变量，即修改类的状态，所以编译器不会让这样的代码通过编译。

## 函数中值的传递

传值：

最常见的参数传递方法。

传引用：

引用底层是使用指针实现的，使用方法也类似与指针。

可以将引用理解为一个具有一定限制的，写法上比较好看的指针。

传引用时压入函数堆栈的数据的大小和指针一样大，32位是4个字节。当要传的变量比较大时，传引用比较快。

函数内部对于传入的引用的修改会影响到真实值，如果不希望函数修改传入值，可以传const引用。

如果可以，返回值也可以传递引用，效率比较高。但注意不可以返回一个局部变量的引用，函数返回后局部变量就会被销毁，引用指向的对象就不存在了，此时必然出错。

传递者无需知道接收者是以引用的方式接收的。

## 友元friend

类中有private部分，外界无法访问，但这个类的友元可以访问。

友元会打破类的封装，不建议多。

友元可以是一个独立的函数，也可以是类。

**相同类的各个对象互为友元**。

## 实现类要注意的几点

- 数据在private中

- 参数尽可能用引用

- 返回值尽可能引用。

- 注意定义常量成员函数。

- 构造函数的初始化列表的使用



## 析构函数

成员变量没有指针的多半不需要写析构函数。

## 操作符重载

注意，操作符重载类似于函数，它会有返回值，所以如果操作符重载设计的好的话可以实现这一样的操作`c3 += c2 += c1`.

操作符重载可以写作类的成员函数，也可以是普通函数。如果是成员函数，编译器会查找c1是否有+=函数，然后把c2当作参数传进去。如果是普通函数，那么编译器会把左边的当作第一个参数，右边的当作第二个参数。

操作符重载有两种实现方式，但是对于同一个操作符只能实现其中一个，比如不能在既在ClassA中实现一个成员函数+，又实现了一个参数是ClassA的非成员函数的+，这样编译器不知道该调用那个函数，会报错。

如何选择这两种实现方式呢，如果用成员函数方式，左操作数必须是实现了这个操作符的对象，右操作数是操作符重载函数的参数。如果用普通函数方式，那么左右操作数可随意放置。比如：成员函数只能做到`string("hello") + "world"`, 而普通函数则可以实现` "world" + string("hello")` ，但是成员函数可以类内部的私有方法与私有变量，普通函数必须通过友元才能访问。

```c++
//非成员函数操作符重载
inline ClassA operator + (const ClassA& x, const ClassA &y)
{
    //do something
    return ClassA sum;
}

//成员函数操作符重载。
```

加号与正号的区分：

加号与正号都是 +，操作符重载如何区分呢？这两个操作符函数的参数不一样。

加号有两个参数，正号只有一个。



## 临时对象

形式： typename()，例如：ClassA(); int(3);都是临时对象。

临时对象没有名称，只存活在当前行，执行完当前行，临时对象的生命周期就会结束。

## 三个特殊函数

String的实现

```c++
class String
{
public:
    String(const char *cstr = 0);//一般构造
    String(const String& str);//拷贝构造
    String& operator = (cost String &str);//赋值操作符重载
    ~String();//析构
    char* get_c_str() const {return m_data;}
private:
    char *m_data;
}
```

### 拷贝构造函数

下面情况会调用拷贝构造

```c++
String a("hello");
String b(a);//调用拷贝构造
String c = a;//调用拷贝构造，用的是等号，但此时需要创建对象c，所以还是初始化
```



### 赋值操作符重载

下面会调用赋值操作符

```c++
String a("hello");
String b("world");
a = b;//调用赋值操作符，必须是左右操作数都完成初始化后才会调用赋值符。
```

赋值操作符需要进行自我赋值检测，用于防止下列问题

```c++
String a("hello");
a = a;
```



```c++
inline String& String::operator=(const String &str)
{
	//检测自我赋值
    if(this == &str)
        return *this;
    //进行指针深拷贝，如果没有自我赋值检测，下面就会出错
    delete[] m_data;//如果str是自己，这里就自杀了。
    m_data = new char[strlen(str.m_data) + 1];
    strcpy(m_data, str.m_data);
    return *this;
}
```



### 析构函数

对象死亡时会调用析构函数

## 堆与栈

栈（stack），是存在于某个作用域的的一块内存空间，当调用一个函数，函数本身就会形成一个栈来放置它所接收的参数，以及返回地址，在函数本体内声明的任何变量其所使用的内存都取自于该函数的栈。离开作用域后栈上的对象就会被清理，这种会被自动清理的对象叫做auto local object。可以在一个对象前面加上static关键字，让他成为一个static local object，即使离开作用域，static local object也不会被清理，当程序结束时这种对象才会被清理。当一个对象在所有花括号作用域之外时，它就会成为global object，这种对象在程序结束时才会被清理。

堆（heap），是由操作系统提供的一块全局内存空间，程序可以动态分配从中获取若干块区域。堆中的对象叫heap object ，他们的生命在他们被deleted后结束。

`new`操作符的背后：现申请内存，在调用构造函数。
例如`Complex *pc = new Complex(1,2);`， 编译器会将其转化为:

```
Complex *pc;
void *mem = operator new(sizeof(Complex)); //分配内存,内部调用malloc()函数
pc = static_cast<Complex*>(mem);//类型转换
pc->Complex::Complex(1,2);//调用构造函数。
//构造函数也是一个成员函数，会有this指针传入。例如：
//Complex::Complex(pc,1,2);
```

`delete` 操作符背后：先调用析构，再释放内存

`delete ps` 会被转换为：

```
String::~String(ps); //析构函数
operator delete(ps);//释放内存，内部调用free函数。
```

## 动态分配后的内存块：（在VC编译器中）

![动态分配后的内存块](/动态分配后的内存块.PNG)

new一个对象后在内存中数据的具体分布如上图所示，

debug模式的内存分配是靠左边长的那个。release是右边短的那个。

每个区域代表4个字节
草绿色的区域代表对象真实的数据区域，灰色的是debug模式中多出来的调试信息。浅绿色的区域是空白填充，因为编译器分配的内存必须是16的倍数，不是的需要补齐。枣红色区域是标志区块，代表一个内存区域的开始与结束。

### 标识区块的简单说明：

我们在使用堆对象时使用的时指针，指针只保存了对象的开始地址，当我们调用delete 或 free函数释放指针时，这两个函数时怎么知道这个对象占用了多少内存，应该释放多少内存呢？当我们申请内存时系统又是怎么知道那块内存没有被占用呢？标志区块可以解决上述问题。

标志区块保存了该对象占用内存的大小，表征了该内存块是否正在使用。拿第一个对象中标志区块中的0x41举例，0x41可以表示为0x40+0x01，0x40代表了该内存块的大小，从16进制转换为10进制就是4*16=64个字节，然后free和delete便知道了应该清理多大的内存区域了。由于vc编译器规定每个内存块的大小必须时16的倍数，所以用16进制表示的内存区块大小最后一位一定是0，系统就用最后一位表示该区块是否被占用，填入1代表该区域被占用，0代表还没有被占用。



## 动态分配数组后的内存块：（在VC编译器中）

动态分配数组对象使用new Obj[] 和 delete[]进行。

![动态分配数组后的内存块](/动态分配数组后的内存块.PNG)

数组内存块比单一对象内存块多了一点东西。他是由标志区块，数组数量区块，数组对象内容区块，填充区块（如果需要）组成，比单一对象内存块多了一个数组数量区块，

如果我们使用new Obj[] 申请了一个数组内存块，但是使用了delete而非delete[]来清除内存块会发生什么？

TODO

delete操作符会调用析构然后释放内存，由于标志区块的存在，它不会少释放，但它会以为只有一个对象，所以只调用一次析构。而delete[]会根据数组数量区块调用相应次数的析构函数。

所以如果类中没有指针神么的，用delete删除数组是没有什么问题的。但不建议这么做



## static成员

static成员变量与static成员函数

static成员变量只有一份， static成员函数不会传入this指针。

static成员变量必须在类外进行定义，注意是定义，在类外定义后才会给该静态成员变量分配内存



## 面向对象编程：OOP

类与类之间的关系：

- 继承（inheritance）：is-a
- 复合（composition）：has a
- 委托（delegation）：has-a-pointer

### 复合

类里面有另一个类，构造时由内而外，析构时由外而内。类

### 委托

类里面有另一个类的指针，两个类的声明周期可以不同。

Handle/Body模式：handle是对外接口，body具体实现，handle里面有body的指针，handle不变，功能更新可以只修改body。
还可以用来做引用计数。

写时复制

### 继承

子类里有父类的全部数据。子类拥有父类函数的调用权。（数据可以复制，函数只会有一份）

构造时由内而外，析构时由外而内。子类会先调用父类的默认构造函数，如果不希望调用父类的默认构造函数或者父类没有默认构造函数，要再初始化列表中手动调用指定的父类构造函数。析构时先析构子类，再析构父类。

### 虚函数与多态

```c++
virtual void pure_virtual()  = 0;//纯虚函数
virtual void impure_virtual();//虚函数
void non_virtual();//非虚函数
```

非虚函数：不希望子类重新定义（override）它；

设计模式：Template Method：父类在一个接口中调用一个虚函数，子类实现它，就可以实现不同的功能。

继承与复合关系下的构造与析构。

一个子类里面有另一个类成员变量，父类，子类，成员类，他们构造函数的执行顺序是什么？

### 委托的设计

Composite模式：
![](/composite模式.PNG)

可以用于实现文件系统，文件系统中有文件和文件夹，文件夹下可以有文件和文件夹。

设计一个文件系统元素基类，文件类和文件夹类继承它， 文件夹类有一个文件系统元素指针数组，用于容纳下级文件和文件夹。

prototype模式

