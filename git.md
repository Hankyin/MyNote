# git基本使用

​      

## git配置

`git config`  命令用来读取和写入环境变量，环境变量会存在特定的配置文件中     环境变量分为3级，系统，用户，仓库。  

| 命令               | 影响的配置文件 | 作用域   |
| ------------------ | -------------- | -------- |
| git config –system | /etc/gitconfig | 系统全局 |
| git config –global | ~/.gitconfig   | 当前用户 |
| git config         | .git/config    | 当前仓库 |

  配置文件的具体内容   

> [user] 
> ​          name = loufand 
> ​          email = loufand@139.com

1. `git config --global user.name "loufand"` 设置用户名
2. `git config --global user.email  "loufand@139.com"` 设置用户名邮箱
3. `git config core.editor emacs` 设置编辑器
4. `git config --list` 列出全部变量
5. `git config <key>` 列出指定的变量

    

## 建立git仓库

  

1. `git init` 建立一个空的仓库，即在当前目录下建立.git文件夹
2. `git clone <path>` 克隆已有仓库

    

## git文件操作

  

- `git add <file/folder>` 跟踪新文件，添加修改到下一次提交中。如果参数是文件夹，会递归跟踪所有文件夹下的文件。
- `git commit` 将当前暂存区中的修改提交到版本库中。该操作会根据core.editor打开指定的编辑器，在编辑器中输入本次提交的说明，退出编辑器后git会丢掉#开头的注释行，然后生成一次提交。
- `git commit -m <msg>` 在-m 后直接输入提交信息，不进入编辑器编辑了。
- `git commit -a` 跳过add阶段，直接将所有跟踪的文件提交。
- `git rm <file>` 让git停止跟踪某个文件，并将其工作区中删除，此命令相当于一次修改，需要commit才能在版本库中删除该文件。
- `git  rm --cached <file>` 让git停止跟踪某个文件。但是不在工作区中删除它。
- `git mv <srcfile> <targetfile>`  移动文件，也可以实现改名。
- `git reset HEAD <file>` 撤销暂存。文件提交到暂存区，该命令可以将暂存区的文件修改删除。但是不会修改工作目录中的文件。
- `git reset HEAD --hard <file>` 撤销暂存，同时也会修改工作目录中的文件。
- `git checkout --<file>` 撤销工作目录中做的修改，将指定的文件变为上次add到暂存区的样子 


## git查看修改

  

- `git status` 查看当前git中文件的状态
- `git status -s` 以简单形式查看状态。


| 状态标记 | 含义                         |
| -------- | ---------------------------- |
| ??       | 未跟踪文件                   |
| A        | 新添加到暂存区的文件         |
| 右边的M  | 文件被修改但还没有放入暂存区 |
| 左边的M  | 文件被修改并且已经放入暂存区 |

   

- `git diff` 查看文件具体修改了哪些行 注意该命令只显示在工作区中尚未暂存的改动。而不是上次提交以来所做的所有改动，当把工作区中的修改暂存后该命令就什么都不显示了。
- `git diff --staged` 查看已经暂存的改动。
- `git log` 查看提交日志


## git忽略文件

  

我们总会有一些文件无需让git管理，也不想让它们出现在未跟踪列表中，比如编译生成的二进制文件，日志文件，一些配置文件。 
 我们可以在仓库中建立一个`.gitignore` 文件来告诉git要忽略那些文件。 
 .gitignore文件格式规范 
 \- #为注释标记 
 \- 可以使用glob模式匹配 
 \- 可以以(/)开头以防止递归 
 \- 可以以(/)结尾指定目录 
 \- 在文件名前加(!)可以取消忽略

  

glob模式指的是shell使用的一种简化的正则表达式

  

| 符号  | 含义                     |
| ----- | ------------------------ |
| *     | 零或多个任意字符         |
| **    | 匹配任意中间目录         |
| [abc] | 匹配[]中的任意一个字符   |
| [0-9] | 匹配0到9中的任意一个字符 |
| ?     | 匹配一个任意字符         |

   ## git的标签（tag）

git可以给某个提交打上一个标签，来表示重要，便于快速查找

标签无法直接签出，只能通过在标签上创建一个分支来签出

`git tag` 列出当前已有的标签，这个命令以字母顺序列出标签

`git checkout -b [branchname] [tagname]` 在特定的标签上创建一个新的分支。

# git的分支branch

分支可以把你的工作从主线开发上分离出来，以免影响开发主线。

## git 数据保存格式

git add 操作会计算指定文件的校验和，然后创建一个blob对象保存文件信息。

git commit 会先计算文件夹的校验和，生成一个tree对象，用来保存文件之间的目录关系，最后创建一个commit对象，存入仓库。

| 数据对象 | 功能                       | 保存的数据内容                                 |
| -------- | -------------------------- | ---------------------------------------------- |
| blob     | 存储特定文件数据           | 文件的校验和等数据，代表一个文件               |
| tree     | 存储提交文件之间的目录关系 | 文件目录关系的描述                             |
| commit   | 整体提交对象。             | 作者信息，提交信息，父对象指针，tree对象指针。 |

```


blob	blob	blob

  \       |      /

          |
    
         tree
    
          |
    
       commit1    <-   commit2    <-  commit3


```

## 分支的本质

git 分支的本质就是一个包含所指向的commit对象的校验和（长度为40的SHA-1值字符串）的文件，所以创建一个分支就相当于向数据库中添加41个字节（40个SHA字符与一个换行符），所以非常高效

创建分支可以简单理解为创建一个指向commit对象的指针。所以多个分支可以指向同一个提交。

一个仓库中可能会有很多分支，但是处于工作状态的分支只能有一个，git使用一个叫HEAD的指针来指向当前工作分支。要切换当前工作分支只需要修改HEAD指向的分支就好了。

```
             HEAD
              |
            branch1
              |
commit1 <- commit2 <- commit3
                         |
                      branch2
```

我们所做的一切更改只会在HEAD指针指向的分支上生效。当我们在一个比较旧的分支上提交后，就会产生提交分叉，我们可以在合适的时候将其合并（merge）

建立一个新的仓库后git会自动建立一个分支，叫master。master分支和普通分支没有什么区别，并不特殊，之所以几乎每个仓库都有master分支，只是因为git默认创建它，并且人们都懒得改动它。

## 分支基本操作

`git branch` 列出当前所有分支。

`git branch -v` 查看所有分支最后一次提交的信息。

`git branch <branch name>` 创建分支，（不切换到新分支）

`git  checkout  <branch name>` 切换到指定分支。注意，在切换分支后，你的工作目录里的文件会被更改为该分支最后一次提交时的样子。

`git checkout -b <branch name>` 创建并切换到指定分支。

`git checkout -d <branch name>` 删除指定分支

`git merge <branch name>` 将指定的分支合并到当前分支。

## git合并

将不同的分支融合到一起叫做分支合并(merge)，`git merge`命令可以实现这一功能。根据有无提交分叉，git合并可以分为快进合并和一般合并。

### 快进合并（fast-forward）

```
           branch1
             |
commit1 <- commit2 <- commit3
                         |
                      branch2
```

假设当前工作分支为branch1，希望合并branch2，在执行merge命令后，git会直接把branch1指向的提交对象修改为commit3，这就是快进合并。

换句话说，合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么git在合并两者时只会简单的将指针向前推进。

### 一般合并
```
                      branch1
                        |
commit1 <- commit2 <- commit3
                \
                 commit4 <- commit5 
                               |
                            branch2
```

如果提交历史存在分叉现象，即当前工作分支不是被合并分支的直接提交祖先的时候，git将无法直接通过移动指针来实现分支的合并。这是更加一般的情况。

此时git会使用两个分支的末端指向的提交对象（commit3 和commit5）以及 两个分支的工作祖先（commit2）来做一个三方合并。git会根据三方的文件内容创建一个新的提交对象。然后将当前的工作分支指向这个新的提交对象。

新创建的这个对象有两个父对象。

```
                                     branch1
                                        |
commit1 <- commit2 <- commit3     <- commit6
                \                   /
                 commit4 <- commit5 
                               |
                            branch2
```

注意，进行三方合并时不一定会十分顺利，比如两个分支对同一个文件的同一处进行了修改，此时git不会主动去合并这个文件。git会暂停下来，抛出一个冲突，通知用户来进行手动合并。用户可以使用git status来查看存在冲突的文件。当用户处理完一个冲突文件后，使用 git add命令将该文件标记为冲突已解决。如果所有的冲突都被解决，用户就可以执行git commit命令来创建合并后的提交对象，提交成功后此次合并完成。

## 远程分支

远程引用是对远程仓库的引用，

# git的远程仓库

  为了与他人合作，git可以连接到其他的远程仓库。

远程仓库指的是托管在互联网或其他网络中的你的项目的版本库。

远程库可以有多个，有的只能读取，有的能够读写。

## 查看远程仓库

  `git remote` 查看远程仓库

`git remote -v` 查看远程仓库，显示远程仓库的URL与权限。

`git remote show [remote-name]` 查看远程仓库更多信息。

## 添加远程仓库

`git remote add <shortname> <url>` 添加远程仓库

## 从远程仓库中拉取数据

`git fetch [remote-name]` 从远程仓库拉取数据，

`git pull [remote-name]` 从远程仓库拉取数据并合并（merge）。

## 推送数据到远程仓库

`git push [remote-name] [local-branch]` 推送数据

## 远程仓库的移除与重命名

` git remote rename ` 重命名远程仓库

`git remote rm ` 删除远程仓库



